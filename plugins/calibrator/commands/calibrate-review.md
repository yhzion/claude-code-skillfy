---
name: calibrate review
description: Review accumulated patterns and promote to Skills
allowed-tools: Bash(sqlite3:*), Bash(test:*), Bash(mkdir:*), Bash(sed:*), Bash(printf:*), Bash(tr:*), Bash(cut:*), Bash(date:*), Bash(echo:*), Bash(awk:*)
---

# /calibrate review

Review repeated patterns and promote them to Skills.

## Pre-execution Setup

### Step 0: Dependency and DB Check
```bash
set -euo pipefail
IFS=$'\n\t'

DB_PATH=".claude/calibrator/patterns.db"
THRESHOLD=2
SKILL_OUTPUT_PATH=".claude/skills/learned"

if ! command -v sqlite3 &> /dev/null; then
  echo "‚ùå Error: sqlite3 is required but not installed."
  exit 1
fi

if [ ! -f "$DB_PATH" ]; then
  echo "‚ùå Calibrator is not initialized. Run /calibrate init first."
  exit 1
fi
```

## Flow

### Step 1: Query Promotion Candidates
```bash
# Query patterns meeting threshold that haven't been promoted.
# Columns: id, situation, instruction, count, first_seen, last_seen
CANDIDATES=$(sqlite3 -separator $'\t' "$DB_PATH" \
  "SELECT id, situation, instruction, count, first_seen, last_seen FROM patterns WHERE count >= $THRESHOLD AND promoted = 0 ORDER BY count DESC LIMIT 100;" \
  2>/dev/null) || CANDIDATES=""
```

### Step 2-A: No Candidates
```
üìä No patterns available for promotion

Patterns need to repeat 2+ times to be promoted to a Skill.
Keep recording with /calibrate.
```

### Step 2-B: Candidates Found
```
üìä Skill Promotion Candidates (2+ repetitions)

[id=12] Model creation ‚Üí Always include timestamp fields (3 times)
[id=15] API endpoint ‚Üí Always include error handling (2 times)

Enter pattern id(s) to promote (comma-separated for multiple): _
```

### Step 3: Load Pattern Details
For each selected `PATTERN_ID`:
```bash
# Validate id defensively
if ! [[ "$PATTERN_ID" =~ ^[0-9]+$ ]]; then
  echo "‚ùå Error: Invalid pattern id '$PATTERN_ID'"
  exit 1
fi

ROW=$(sqlite3 -separator $'\t' "$DB_PATH" \
  "SELECT situation, instruction, count, first_seen, last_seen FROM patterns WHERE id = $PATTERN_ID AND promoted = 0;" \
  2>/dev/null) || ROW=""

if [ -z "$ROW" ]; then
  echo "‚ùå Error: Pattern not found or already promoted (id=$PATTERN_ID)"
  exit 1
fi

IFS=$'\t' read -r SITUATION INSTRUCTION COUNT FIRST_SEEN LAST_SEEN <<<"$ROW"
```

### Step 4: Skill Preview
```
üìù Skill Preview: {situation}

---
name: {kebab-case situation}
description: {instruction}. Auto-applied in {situation} situations.
learned_from: calibrator ({count} repetitions, {first_seen} ~ {last_seen})
---

## Rules

{instruction}

## Applies to

- {situation}

## Learning History

This Skill was auto-generated by Calibrator.
- First detected: {first_seen}
- Last detected: {last_seen}
- Repetitions: {count}

---

[Save] [Edit] [Skip]
```

### Step 5: Skill Creation
On save selection:
```bash
# Generate Skill name (kebab-case) - Path Traversal prevention
SKILL_NAME=$(printf '%s' "$SITUATION" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
# Collapse multiple consecutive hyphens and remove leading/trailing hyphens
SKILL_NAME=$(printf '%s' "$SKILL_NAME" | sed 's/-\{2,\}/-/g; s/^-//; s/-$//')
SKILL_NAME=$(printf '%s' "$SKILL_NAME" | cut -c1-50)
# Remove any trailing hyphen that might result from truncation
SKILL_NAME=$(printf '%s' "$SKILL_NAME" | sed 's/-$//')
if [ -z "$SKILL_NAME" ]; then
  SKILL_NAME="skill-$(date +%Y%m%d-%H%M%S)"
fi

# Handle skill name collisions atomically using mkdir (avoids TOCTOU race condition)
# First ensure parent directory exists
mkdir -p "$SKILL_OUTPUT_PATH"

BASE_SKILL_NAME="$SKILL_NAME"
SUFFIX=0
MAX_ATTEMPTS=100
SKILL_DIR=""

while [ $SUFFIX -le $MAX_ATTEMPTS ]; do
  if [ $SUFFIX -eq 0 ]; then
    CURRENT_NAME="$BASE_SKILL_NAME"
  else
    CURRENT_NAME="${BASE_SKILL_NAME}-${SUFFIX}"
  fi

  # mkdir (without -p) fails if directory exists - atomic check+create
  if mkdir "$SKILL_OUTPUT_PATH/$CURRENT_NAME" 2>/dev/null; then
    SKILL_NAME="$CURRENT_NAME"
    SKILL_DIR="$SKILL_OUTPUT_PATH/$SKILL_NAME"
    break
  fi
  SUFFIX=$((SUFFIX + 1))
done

if [ -z "$SKILL_DIR" ]; then
  echo "‚ùå Error: Failed to generate unique skill name after $MAX_ATTEMPTS attempts"
  exit 1
fi

# Escape variables for sed substitution (handles multi-line and special characters)
escape_sed() {
  printf '%s' "$1" | awk '
    BEGIN { ORS="" }
    {
      gsub(/\\/, "\\\\")
      gsub(/&/, "\\\\&")
      gsub(/\|/, "\\|")
      if (NR > 1) printf "\\n"
      print
    }
  '
}
SAFE_SKILL_NAME=$(escape_sed "$SKILL_NAME")
SAFE_INSTRUCTION=$(escape_sed "$INSTRUCTION")
SAFE_SITUATION=$(escape_sed "$SITUATION")

# Generate Skill using template file
sed -e "s|{{SKILL_NAME}}|$SAFE_SKILL_NAME|g" \
    -e "s|{{INSTRUCTION}}|$SAFE_INSTRUCTION|g" \
    -e "s|{{SITUATION}}|$SAFE_SITUATION|g" \
    -e "s|{{COUNT}}|$COUNT|g" \
    -e "s|{{FIRST_SEEN}}|$FIRST_SEEN|g" \
    -e "s|{{LAST_SEEN}}|$LAST_SEEN|g" \
    plugins/calibrator/templates/skill-template.md > "$SKILL_OUTPUT_PATH/$SKILL_NAME/SKILL.md"

# SQL Injection prevention: escape single quotes
escape_sql() {
  printf '%s' "$1" | sed "s/'/''/g"
}
SAFE_SKILL_PATH=$(escape_sql "$SKILL_OUTPUT_PATH/$SKILL_NAME")
sqlite3 "$DB_PATH" "UPDATE patterns SET promoted = 1, skill_path = '$SAFE_SKILL_PATH' WHERE id = $PATTERN_ID;"
```

### Step 6: Completion
```
‚úÖ Skill created

- {skill_output_path}/{skill-name}/SKILL.md

Claude will now automatically apply this rule in "{situation}" situations.
```

## Reference: Skill Name Conversion Rules

- Space ‚Üí hyphen
- Uppercase ‚Üí lowercase
- Remove special characters
- Example: "Model creation" ‚Üí "model-creation"
- Example: "API endpoint" ‚Üí "api-endpoint"
