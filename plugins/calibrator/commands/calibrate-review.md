---
name: calibrate review
description: Review accumulated patterns and promote to Skills
allowed-tools: Bash(git:*), Bash(sqlite3:*), Bash(test:*), Bash(mkdir:*), Bash(sed:*), Bash(printf:*), Bash(tr:*), Bash(cut:*), Bash(date:*), Bash(echo:*), Bash(awk:*)
---

# /calibrate review

Review repeated patterns and promote them to Skills.

## Pre-execution Setup

### Step 0: Dependency and DB Check
```bash
set -euo pipefail
IFS=$'\n\t'

# Ensure UTF-8 locale for proper character handling
export LC_ALL=C.UTF-8 2>/dev/null || export LC_ALL=en_US.UTF-8 2>/dev/null || true

# Get project root (Git root or current directory as fallback)
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
DB_PATH="$PROJECT_ROOT/.claude/calibrator/patterns.db"
THRESHOLD=2
SKILL_OUTPUT_PATH="$PROJECT_ROOT/.claude/skills"

# POSIX-compatible version comparison (returns 0 if $1 >= $2)
version_ge() {
  printf '%s\n%s' "$2" "$1" | awk -F. '
    NR==1 { split($0,a,"."); next }
    NR==2 { split($0,b,".")
      for(i=1; i<=3; i++) {
        if((b[i]+0) > (a[i]+0)) exit 0
        if((b[i]+0) < (a[i]+0)) exit 1
      }
      exit 0
    }'
}

if ! command -v sqlite3 &> /dev/null; then
  echo "‚ùå Error: sqlite3 is required but not installed."
  exit 1
fi

# SQLite 3.24.0+ required for UPSERT support
SQLITE_VERSION=$(sqlite3 --version 2>/dev/null | awk '{print $1}')
MIN_SQLITE_VERSION="3.24.0"
if ! version_ge "$SQLITE_VERSION" "$MIN_SQLITE_VERSION"; then
  echo "‚ùå Error: SQLite $MIN_SQLITE_VERSION or higher required. Found: ${SQLITE_VERSION:-unknown}"
  exit 1
fi

if [ ! -f "$DB_PATH" ]; then
  echo "‚ùå Calibrator is not initialized. Run /calibrate init first."
  exit 1
fi
```

## Flow

### Step 1: Query Promotion Candidates
```bash
# Query patterns meeting threshold that haven't been promoted.
# Columns: id, situation, instruction, count, first_seen, last_seen
CANDIDATES=$(sqlite3 -separator $'\t' "$DB_PATH" \
  "SELECT id, situation, instruction, count, first_seen, last_seen FROM patterns WHERE count >= $THRESHOLD AND promoted = 0 ORDER BY count DESC LIMIT 100;" \
  2>/dev/null) || CANDIDATES=""
```

### Step 2-A: No Candidates
```
üìä No patterns available for promotion

Patterns need to repeat 2+ times to be promoted to a Skill.
Keep recording with /calibrate.
```

### Step 2-B: Candidates Found

First, display the candidates list:
```
üìä Skill Promotion Candidates (2+ repetitions)

[id=12] Model creation ‚Üí Always include timestamp fields (3 times)
[id=15] API endpoint ‚Üí Always include error handling (2 times)
```

Then use the `AskUserQuestion` tool to ask the user to select patterns:

```
header: "Select"
question: "Which pattern(s) would you like to promote to Skills?"
multiSelect: true
options:
  - label: "[id=12] Model creation (3x)"
    description: "Always include timestamp fields"
  - label: "[id=15] API endpoint (2x)"
    description: "Always include error handling"
  - label: "Skip all"
    description: "Don't promote any patterns now"
```

Note: Options should be dynamically generated from the CANDIDATES query result.
If user selects "Skip all", exit with message: "No patterns promoted."

### Step 3: Load Pattern Details
For each selected `PATTERN_ID`:
```bash
# Validate id defensively
if ! [[ "$PATTERN_ID" =~ ^[0-9]+$ ]]; then
  echo "‚ùå Error: Invalid pattern id '$PATTERN_ID'"
  exit 1
fi

ROW=$(sqlite3 -separator $'\t' "$DB_PATH" \
  "SELECT situation, instruction, count, first_seen, last_seen FROM patterns WHERE id = $PATTERN_ID AND promoted = 0;" \
  2>/dev/null) || ROW=""

if [ -z "$ROW" ]; then
  echo "‚ùå Error: Pattern not found or already promoted (id=$PATTERN_ID)"
  exit 1
fi

IFS=$'\t' read -r SITUATION INSTRUCTION COUNT FIRST_SEEN LAST_SEEN <<<"$ROW"
```

### Step 4: Skill Preview and Confirmation

Display the skill preview:
```
üìù Skill Preview: {situation}

---
name: {kebab-case situation}
description: {instruction}. Auto-applied in {situation} situations.
learned_from: calibrator ({count} repetitions, {first_seen} ~ {last_seen})
---

## Rules

{instruction}

## Applies to

- {situation}

## Learning History

This Skill was auto-generated by Calibrator.
- First detected: {first_seen}
- Last detected: {last_seen}
- Repetitions: {count}
```

Then use the `AskUserQuestion` tool to confirm:

```
header: "Action"
question: "What would you like to do with this skill?"
options:
  - label: "Save skill (Recommended)"
    description: "Create the skill file and activate it"
  - label: "Edit first"
    description: "Modify the instruction before saving"
  - label: "Skip"
    description: "Don't create this skill"
```

- "Save skill" ‚Üí Proceed to Step 5
- "Edit first" ‚Üí Ask user for modified instruction via AskUserQuestion, then proceed to Step 5
- "Skip" ‚Üí Skip this pattern and continue to next (if any)

### Step 5: Skill Creation
On save selection:
```bash
# Generate Skill name (kebab-case) - Path Traversal prevention
SKILL_NAME=$(printf '%s' "$SITUATION" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
# Collapse multiple consecutive hyphens and remove leading/trailing hyphens
SKILL_NAME=$(printf '%s' "$SKILL_NAME" | sed 's/-\{2,\}/-/g; s/^-//; s/-$//')
SKILL_NAME=$(printf '%s' "$SKILL_NAME" | cut -c1-50)
# Remove any trailing hyphen that might result from truncation
SKILL_NAME=$(printf '%s' "$SKILL_NAME" | sed 's/-$//')
if [ -z "$SKILL_NAME" ]; then
  SKILL_NAME="skill-$(date +%Y%m%d-%H%M%S)"
fi

# Handle skill name collisions atomically using mkdir (avoids TOCTOU race condition)
# First ensure parent directory exists
mkdir -p "$SKILL_OUTPUT_PATH"

BASE_SKILL_NAME="$SKILL_NAME"
SUFFIX=0
MAX_ATTEMPTS=100
SKILL_DIR=""

while [ $SUFFIX -le $MAX_ATTEMPTS ]; do
  if [ $SUFFIX -eq 0 ]; then
    CURRENT_NAME="$BASE_SKILL_NAME"
  else
    CURRENT_NAME="${BASE_SKILL_NAME}-${SUFFIX}"
  fi

  # mkdir (without -p) fails if directory exists - atomic check+create
  if mkdir "$SKILL_OUTPUT_PATH/$CURRENT_NAME" 2>/dev/null; then
    SKILL_NAME="$CURRENT_NAME"
    SKILL_DIR="$SKILL_OUTPUT_PATH/$SKILL_NAME"
    break
  fi
  SUFFIX=$((SUFFIX + 1))
done

if [ -z "$SKILL_DIR" ]; then
  echo "‚ùå Error: Failed to generate unique skill name after $MAX_ATTEMPTS attempts"
  exit 1
fi

# Escape variables for sed substitution (handles multi-line and special characters)
escape_sed() {
  printf '%s' "$1" | awk '
    BEGIN { ORS="" }
    {
      gsub(/\\/, "\\\\")
      gsub(/&/, "\\\\&")
      gsub(/\|/, "\\|")
      if (NR > 1) printf "\\n"
      print
    }
  '
}
SAFE_SKILL_NAME=$(escape_sed "$SKILL_NAME")
SAFE_INSTRUCTION=$(escape_sed "$INSTRUCTION")
SAFE_SITUATION=$(escape_sed "$SITUATION")

# Generate Skill using template file
sed -e "s|{{SKILL_NAME}}|$SAFE_SKILL_NAME|g" \
    -e "s|{{INSTRUCTION}}|$SAFE_INSTRUCTION|g" \
    -e "s|{{SITUATION}}|$SAFE_SITUATION|g" \
    -e "s|{{COUNT}}|$COUNT|g" \
    -e "s|{{FIRST_SEEN}}|$FIRST_SEEN|g" \
    -e "s|{{LAST_SEEN}}|$LAST_SEEN|g" \
    "$PROJECT_ROOT/plugins/calibrator/templates/skill-template.md" > "$SKILL_OUTPUT_PATH/$SKILL_NAME/SKILL.md"

# SQL Injection prevention: escape single quotes
escape_sql() {
  printf '%s' "$1" | sed "s/'/''/g"
}
SAFE_SKILL_PATH=$(escape_sql "$SKILL_OUTPUT_PATH/$SKILL_NAME")
sqlite3 "$DB_PATH" "UPDATE patterns SET promoted = 1, skill_path = '$SAFE_SKILL_PATH' WHERE id = $PATTERN_ID;"

# Output completion message (guaranteed to display)
printf '\n‚úÖ Skill created\n\n- %s/%s/SKILL.md\n\nüîÑ To activate this Skill, start a new Claude Code session.\n   (Skills are loaded at session start)\n\nClaude will then automatically apply this rule in "%s" situations.\n' "$SKILL_OUTPUT_PATH" "$SKILL_NAME" "$SITUATION"
```

## Reference: Skill Name Conversion Rules

- Space ‚Üí hyphen
- Uppercase ‚Üí lowercase
- Remove special characters
- Example: "Model creation" ‚Üí "model-creation"
- Example: "API endpoint" ‚Üí "api-endpoint"
